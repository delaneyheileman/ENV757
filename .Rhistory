sU <- rep(NA, N)
diffvals <- rep(NA, N)
for (i in 1:N) {
sR <- sample(cleanRECS$logKWH[cleanRECS$UrbanRural == "R"],
sum(cleanRECS$UrbanRural == "R"), replace = TRUE)
sU <- sample(cleanRECS$logKWH[cleanRECS$UrbanRural == "U"],
sum(cleanRECS$UrbanRural == "U"), replace = TRUE)
diffvals[i] <- mean((sR)) - mean((sU))
}
ci <- quantile(diffvals, c(0.025, 0.975))
print("Bootstrapped Confidence Intervals")
round(ci, 2)
print("Original Confidence Intervals")
round(test1$conf.int,2)
hist(diffvals,
col = "blue",
main = "Bootstrapped Sample Means Diff in Annual Electricity Use",
xlab = "Kilowatt-hours",
breaks = 50)
#Add lines to histogram for CI's
abline(v = ci, lwd=3, col="red")
abline(v = test1$conf.int, lwd = 3, col = "green", lty = 2)
legend("topleft",
c("Original CI","Boot CI"),
lwd = 3,
col = c("green","red"),
lty = c(2,1))
(actualdiff <- by(cleanRECS$logKWH, cleanRECS$UrbanRural, mean))
(actualdiff <- by(cleanRECS$logKWH, cleanRECS$UrbanRural, mean))
(actualdiff <- by(cleanRECS$logKWH, cleanRECS$UrbanRural, mean))
(actualdiff <- by(cleanRECS$logKWH, cleanRECS$UrbanRural, mean))
?by
# Subset the dataset used for the ANCOVA model, clean the data, and check the characteristics of the dataset.
ancmod <- cleanRECS[c("KWH", "MONEYPY", "CENACHP")]
ancmod$CENACHP <- as.factor(ancmod$CENACHP)
dim(ancmod)
str(ancmod)
#Create initial exploratory boxplots and scatterplots to determine whether the spread and the means of the data indicate similar variance or evidence of related variables. Only a scatterplot is made for KWH vs. MONEYPY because they are the only continuous variables.
attach(ancmod)
boxplot(KWH ~ MONEYPY, data = ancmod, col = terrain.colors(8), xlab = "Annual Gross Income", ylab = "Kilowatt-Hours")
means1 <- round(tapply(KWH,MONEYPY, mean),0)
points(means1, col = 'red', pch = 19, cex = 1.2)
text(x = c(1:8), y = means1, labels = round(means1, 2))
boxplot(KWH ~ CENACHP, data = ancmod, col = c("red3", "green3"), xlab = "Heat Pump", ylab = "Kilowatt-Hours")
means2 <- round(tapply(KWH,CENACHP, mean),0)
points(means1, col = 'red', pch = 19, cex = 1.2)
text(x = c(1:2), y = means2, labels = round(means2, 2))
plot(KWH ~ MONEYPY, data = ancmod, col = "plum4", pch = 21, xlab = "Annual Gross Income", main = "Scatterplot of Kilowatt-Hours versus Annual Gross Income", ylab = "Kilowatt-Hours")
factor(MONEYPY)
#Check Variance Assumption
stdev2 <- tapply(KWH, CENACHP, sd)
round(max(stdev2)/min(stdev2),1)
#check normality assumptions for KWH and MONEYPY
ancmod$KWH[ancmod$KWH < 1500] <- NA
m1 <- lm(KWH ~ CENACHP + MONEYPY, data = ancmod)
summary(m1)
myResPlots2(m1)
#note anomalies
m2 <- lm(KWH ~ MONEYPY, data = ancmod)
summary(m2)
myResPlots2(m2)
#Normality assumptions have not been met by the residuals so a transformation needs to be made. A box cox test will indicate what transformation is approprite for the data.
trans1 <- boxCox(m1)
boxcoxtrans <- trans1$x[which.max(trans1$y)]
print(boxcoxtrans)
#check normality assumptions for KWH and MONEYPY
ancmod$KWH[ancmod$KWH < 1500] <- NA
m1 <- lm(KWH ~ CENACHP + MONEYPY, data = ancmod)
summary(m1)
myResPlots2(m1)
#note anomalies
m2 <- lm(KWH ~ MONEYPY, data = ancmod)
summary(m2)
myResPlots2(m2)
#Normality assumptions have not been met by the residuals so a transformation needs to be made. A box cox test will indicate what transformation is approprite for the data.
trans1 <- boxCox(m1)
boxcoxtrans <- trans1$x[which.max(trans1$y)]
print(boxcoxtrans)
#Log Transformation
ancmod$transKWH <- log(ancmod$KWH)
#check normality assumptions for KWH and CENACHP and KWH and MONEYPY
m3 <- lm(transKWH ~ CENACHP, data = ancmod)
summary(m3)
myResPlots2(m3)
ols_plot_cooksd_bar(m3)
m4 <- lm(transKWH ~ MONEYPY, data = ancmod)
summary(m4)
myResPlots2(m4)
ols_plot_cooksd_bar(m4)
table(MONEYPY, CENACHP)
fitanco <- lm(transKWH ~ MONEYPY + CENACHP + MONEYPY*CENACHP, data = ancmod)
Anova(fitanco, type = 3)
summary(fitanco)
vif(fitanco)
anccoef <- coef(fitanco)
plot(transKWH ~ MONEYPY, data = ancmod, col = factor(CENACHP), pch = 16, cex = .5)
legend("topright", col = 1:2, legend = levels(factor(ancmod$CENACHP)), pch = 16)
abline(a = anccoef[1], b = anccoef[2], col = 1, lwd = 3)
abline(a = anccoef[1] + anccoef[3], b = anccoef[2] + anccoef[4], col = 2, lwd = 3)
fitanco <- lm(transKWH ~ MONEYPY + CENACHP + MONEYPY*CENACHP, data = ancmod)
Anova(fitanco, type = 3)
summary(fitanco)
vif(fitanco)
anccoef <- coef(fitanco)
plot(transKWH ~ MONEYPY,
main = "Log of Annual Electricity Use vs. Income by Presence of Heatpump",
ylab = "Log of Kilowatt-Hours",
xlab = "Income Brackett",
data = ancmod, col = factor(CENACHP), pch = 16, cex = .5)
legend("topright", col = 1:2, legend = levels(factor(ancmod$CENACHP)), pch = 16)
abline(a = anccoef[1], b = anccoef[2], col = 1, lwd = 3)
abline(a = anccoef[1] + anccoef[3], b = anccoef[2] + anccoef[4], col = 2, lwd = 3)
fitanco <- lm(transKWH ~ MONEYPY + CENACHP + MONEYPY*CENACHP, data = ancmod)
Anova(fitanco, type = 3)
summary(fitanco)
vif(fitanco)
anccoef <- coef(fitanco)
plot(transKWH ~ MONEYPY,
main = "Log of Annual Electricity Use vs. Income by Presence of Heatpump",
ylab = "Log of Kilowatt-Hours",
xlab = "Income Brackett",
data = ancmod, col = factor(CENACHP), pch = 16, cex = .5)
legend("topright", col = 1:2, legend = levels(factor(ancmod$CENACHP)), pch = 16)
abline(a = anccoef[1], b = anccoef[2], col = 1, lwd = 3)
abline(a = anccoef[1] + anccoef[3], b = anccoef[2] + anccoef[4], col = 2, lwd = 3)
#This would likely make more sense in a different section after we show the need for it.
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
##FROM CLASS 19
#Creating the linear model
mod1 <- regsubsets(logKWH ~ logIncBracket + DIVISION + UATYP10 + KOWNRENT + DIVISION*UATYP10,
data = cleanRECS, nvmax = 7)
mod1sum <- summary(mod1)
mod1sum$which
mod1sum$which[1, ]
mod1sum <- summary(mod1)
mod1sum$which
mod1sum$which[1, ]
mod1sum$which
lm1 <- lm(cleanRECS$logKWH ~ cleanRECS$logIncBracket*cleanRECS$UATYP10)
summary(lm1)
coefs <- round(coef(lm1), 2)
#Plotting the model to show the lack of impact of household income, but impact of housing type.
plot(cleanRECS$logKWH ~ cleanRECS$logIncBracket,
col = factor(cleanRECS$UATYP10),
pch = 16,
cex = .5,
main = "Energy Consumption vs. Household Income (Log-Log)",
xlab = "Log of Household Income Bracket ($)",
ylab = "Log of Energy Consumption (kWh)")
legend("topleft", col = 1:5, legend = c("Rural", "Urban"), pch = 16)
abline(a = coefs[1], b = coefs[2], col = 1, lwd = 3)
abline(a = coefs[1] + coefs[3], b = coefs[2] + coefs[4], col = 2, lwd = 3)
text(x = 10.25, y = 9.75, col = 1,
paste0("Slope = ", coefs[2]))
text(x = 10.25, y = 8.5, col = 2,
paste0("Slope = ", coefs[2] + coefs[4]))
text(x = 10.25, y = 8.15, col = 2, paste0("but, p ≈ ", round(summary(lm1)$coefficients[4, 4], 2)))
text(x = 10.95, y = 6, col = 1, paste0("Rural energy use tends to be"))
text(x = 10.95, y = 5.65, col = 1, paste0("higher than urban, p-value ≈ ", round(summary(lm1)$coefficients[2, 4], 5), ","))
text(x = 10.95, y = 5.30, col = 1, "for households of similar incomes.")
summary(lm1)
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(leaps)
library(lubridate)
library(rvest)
library(olsrr)
library(corrplot)
library(leaps)
library(tidyverse)
library(ggplot2)
source("http://www.reuningscherer.net/s&ds230/Rfuncs/regJDRS.txt")
## Data - Variables Used
#Setting working directory
#setwd("/Users/delaneyheileman/Documents/school/Yale/Spring 2022/data/ENV757")#
setwd("/Users/liamgunn/Documents/School/Graduate School/Yale Forestry/Spring 2022/Data Exploration & Analysis/Data Analysis Final Project/ENV757")
#setwd("/Users/elain/Documents/GitHub/ENV757")
#Loading CSV
recs <- read.csv("recs2015_public_v4.csv")
#Gettign dimensions of our dataset
dim(recs)
#Printing first 6 lines
head(recs)
#Selecting columns we care about
recs1 <- na.omit(recs[, c("MONEYPY", "ENERGYASST", "REGIONC", "DIVISION","UATYP10", "KOWNRENT", "THERMAIN", "PROTHERM", "TEMPHOME", "AIRCOND","CENACHP", "THERMAINAC", "PROTHERMAC", "TEMPHOMEAC", "HOUSEHOLDER_RACE", "SCALEB", "KWH", "DOLLAREL", "DOLLARNG", "DOLLARLP", "DOLLARFO")])
#Removing "not applicable" answers for thermostat questions. N/a for Thermostat likely means they use wood fire or something else
cleanRECS <- recs1[recs1$THERMAIN != -2 & recs1$THERMAINAC != "-2",]
cleanRECS$REGIONC <- as.factor(recode(cleanRECS$REGIONC,
'1' = 'Northeast',
'2' = 'Midwest',
'3' = 'South',
'4' = 'West'))
boxplot(KWH ~ UATYP10,
data = cleanRECS,
col = terrain.colors(8),
xlab = "Rural, Urban, Suburban",
ylab = "Kilowatt-Hours")
mean <- round(tapply(cleanRECS$KWH,cleanRECS$UATYP10, mean),0)
points(mean, col = 'red', pch = 19, cex = 1.2)
text(x = c(1:8), y = mean, labels = round(mean, 2))
table(cleanRECS$UATYP10)
cleanRECS$UrbanRural <- recode(cleanRECS$UATYP10, 'C' = 'U')
cleanRECS$DIVISION <- as.factor(recode(cleanRECS$DIVISION,
'1' = 'New England',
'2' = 'Mid Atlantic',
'3' = 'East North Central',
'4' = 'West North Central',
'5' = 'South Atlantic',
'6' = 'East South Central',
'7' = 'West South Central',
'8' = 'Mountain North',
'9' = 'Mountain South',
'10'= 'Pacific'))
cleanRECS$CENACHP <- recode(cleanRECS$CENACHP,
'1' = 'YES',
'0' = 'NO')
#recoding energy assistance variable to yes or no value
cleanRECS$ENERGYASST <- recode(cleanRECS$ENERGYASST,
'1' = 'YES',
'0' = 'NO')
#Converting the Income Brackets into a numeric variable. Because we do not know the exact variables, we are assuming that each household is at the upper limit of that income bracket, and removing the highest income bracket that has no upper limit to avoid making unbounded assumptions about their incomes.
cleanRECS$IncBracket <- as.numeric(recode(cleanRECS$MONEYPY,
'1' = '20000',
'2' = '40000',
'3' = '60000',
'4' = '80000',
'5' = '100000',
'6' = '120000',
'7' = '140000',
'8' = 'NA'))
boxplot(KWH ~ REGIONC,
data = cleanRECS,
col = terrain.colors(length(unique(cleanRECS$REGIONC))),
main = "Kilowatt Hours vs. Climate Region",
xlab = "Census Region",
ylab = "Kilowatt-Hours")
mean <- round(tapply(cleanRECS$KWH,cleanRECS$REGIONC, mean),0)
points(mean, col = 'red', pch = 19, cex = 1.2)
text(x = c(1:length(unique(cleanRECS$REGIONC))), y = mean, labels = round(mean, 2))
boxplot(KWH ~ UrbanRural,
data = cleanRECS,
col = terrain.colors(length(unique(cleanRECS$UrbanRural))),
main = "Kilowatt Hours vs. Urban/Rural Divide",
xlab = "Rural v. Urban",
ylab = "Kilowatt-Hours")
mean <- round(tapply(cleanRECS$KWH,cleanRECS$UrbanRural, mean),0)
points(mean, col = 'red', pch = 19, cex = 1.2)
text(x = c(1:length(unique(cleanRECS$UrbanRural))), y = mean, labels = round(mean, 2))
plot(cleanRECS$KWH, cleanRECS$DOLLAREL,
main = "Kilowatt Hours vs. Electricty Expenditure",
xlab = "Kilowatt Hours (by household)",
ylab = "Electricty Expenditure",
col = "blue")
hist(cleanRECS$KWH,
col = "salmon",
main = "Distribution of Annual Electricty Use",
xlab = "kilowatt hours",
breaks = 50,)
qqPlot(cleanRECS$KWH)
cleanRECS$logKWH <- log(cleanRECS$KWH)
hist(cleanRECS$logKWH,
col = "salmon",
main = "Distribution of Log Kilowatt-Hours",
xlab = "Log of Kilowatt-hours",
breaks = 50,)
qqPlot(cleanRECS$logKWH)
#boxplot of log values
boxplot(logKWH ~ UrbanRural,
main = "Log of Annual Electricty Use vs. Urban/Rural Divide",
ylab = "Log of Kilowatt-Hours",
data = cleanRECS,
col = as.factor(cleanRECS$logKWH),
xlab = "Rural vs. Urban")
#t.test of KWH and region type
(test1 <- t.test(logKWH ~ UrbanRural, data = cleanRECS, conf.level = .95))
set.seed(230)
N <- 10000
sR <- rep(NA, N)
sU <- rep(NA, N)
diffvals <- rep(NA, N)
for (i in 1:N) {
sR <- sample(cleanRECS$logKWH[cleanRECS$UrbanRural == "R"],
sum(cleanRECS$UrbanRural == "R"), replace = TRUE)
sU <- sample(cleanRECS$logKWH[cleanRECS$UrbanRural == "U"],
sum(cleanRECS$UrbanRural == "U"), replace = TRUE)
diffvals[i] <- mean((sR)) - mean((sU))
}
ci <- quantile(diffvals, c(0.025, 0.975))
print("Bootstrapped Confidence Intervals")
round(ci, 2)
print("Original Confidence Intervals")
round(test1$conf.int,2)
hist(diffvals,
col = "blue",
main = "Bootstrapped Sample Means Diff in Annual Electricity Use",
xlab = "Kilowatt-hours",
breaks = 50)
#Add lines to histogram for CI's
abline(v = ci, lwd=3, col="red")
abline(v = test1$conf.int, lwd = 3, col = "green", lty = 2)
legend("topleft",
c("Original CI","Boot CI"),
lwd = 3,
col = c("green","red"),
lty = c(2,1))
(actualdiff <- by(cleanRECS$logKWH, cleanRECS$UrbanRural, mean))
lm1 <- lm(cleanRECS$logKWH ~ cleanRECS$logIncBracket*cleanRECS$UATYP10)
class(cleanRECS$logIncBracket)
#This would likely make more sense in a different section after we show the need for it.
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
lm1 <- lm(cleanRECS$logKWH ~ cleanRECS$logIncBracket*cleanRECS$UATYP10)
summary(lm1)
coefs <- round(coef(lm1), 2)
#Plotting the model to show the lack of impact of household income, but impact of housing type.
plot(cleanRECS$logKWH ~ cleanRECS$logIncBracket,
col = factor(cleanRECS$UATYP10),
pch = 16,
cex = .5,
main = "Energy Consumption vs. Household Income (Log-Log)",
xlab = "Log of Household Income Bracket ($)",
ylab = "Log of Energy Consumption (kWh)")
legend("topleft", col = 1:5, legend = c("Rural", "Urban"), pch = 16)
abline(a = coefs[1], b = coefs[2], col = 1, lwd = 3)
abline(a = coefs[1] + coefs[3], b = coefs[2] + coefs[4], col = 2, lwd = 3)
text(x = 10.25, y = 9.75, col = 1,
paste0("Slope = ", coefs[2]))
text(x = 10.25, y = 8.5, col = 2,
paste0("Slope = ", coefs[2] + coefs[4]))
text(x = 10.25, y = 8.15, col = 2, paste0("but, p ≈ ", round(summary(lm1)$coefficients[4, 4], 2)))
text(x = 10.95, y = 6, col = 1, paste0("Rural energy use tends to be"))
text(x = 10.95, y = 5.65, col = 1, paste0("higher than urban, p-value ≈ ", round(summary(lm1)$coefficients[2, 4], 5), ","))
text(x = 10.95, y = 5.30, col = 1, "for households of similar incomes.")
summary(mod1)
coefs <- round(coef(lm1), 2)
coefs
summary(lm1)
#This would likely make more sense in a different section after we show the need for it.
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
##FROM CLASS 19
#Creating the linear model
mod1 <- regsubsets(logKWH ~ logIncBracket + DIVISION + UATYP10 + KOWNRENT + DIVISION*UATYP10,
data = cleanRECS, nvmax = 7)
mod1sum <- summary(mod1)
mod1sum$which
mod1sum$which[1, ]
lm1 <- lm(cleanRECS$logKWH ~ cleanRECS$logIncBracket*cleanRECS$UATYP10)
summary(lm1)
coefs <- round(coef(lm1), 2)
#Plotting the model to show the lack of impact of household income, but impact of housing type.
plot(cleanRECS$logKWH ~ cleanRECS$logIncBracket,
col = factor(cleanRECS$UATYP10),
pch = 16,
cex = .5,
main = "Energy Consumption vs. Household Income (Log-Log)",
xlab = "Log of Household Income Bracket ($)",
ylab = "Log of Energy Consumption (kWh)")
legend("topleft", col = 1:5, legend = c("Rural", "Urban"), pch = 16)
abline(a = coefs[1], b = coefs[2], col = 1, lwd = 3)
abline(a = coefs[1] + coefs[3], b = coefs[2] + coefs[4], col = 2, lwd = 3)
text(x = 10.25, y = 9.75, col = 1,
paste0("Slope = ", coefs[2]))
text(x = 10.25, y = 8.5, col = 2,
paste0("Slope = ", coefs[2] + coefs[4]))
text(x = 10.25, y = 8.15, col = 2, paste0("but, p ≈ ", round(summary(lm1)$coefficients[4, 4], 2)))
text(x = 10.95, y = 6, col = 1, paste0("Rural energy use tends to be"))
text(x = 10.95, y = 5.65, col = 1, paste0("higher than urban, p-value ≈ ", round(summary(lm1)$coefficients[2, 4], 5), ","))
text(x = 10.95, y = 5.30, col = 1, "for households of similar incomes.")
coefs <- round(coef(lm1), 2)
coefs
mod1sum$which[1, ]
lm1 <- lm(cleanRECS$logKWH ~ cleanRECS$logIncBracket*cleanRECS$UATYP10)
summary(lm1)
##FROM CLASS 19
#Creating the linear model
mod1 <- regsubsets(logKWH ~ logIncBracket + DIVISION + UATYP10 + KOWNRENT + DIVISION*UATYP10,
data = cleanRECS, nvmax = 7)
mod1sum <- summary(mod1)
mod1sum$which
mod1sum$which[1, ]
mod1sum$which[1, ]
lm1 <- lm(cleanRECS$logKWH ~ cleanRECS$logIncBracket*cleanRECS$UrbanRural)
summary(lm1)
coefs <- round(coef(lm1), 2)
#Plotting the model to show the lack of impact of household income, but impact of housing type.
plot(cleanRECS$logKWH ~ cleanRECS$logIncBracket,
col = factor(cleanRECS$UrbanRural),
pch = 16,
cex = .5,
main = "Energy Consumption vs. Household Income (Log-Log)",
xlab = "Log of Household Income Bracket ($)",
ylab = "Log of Energy Consumption (kWh)")
legend("topleft", col = 1:5, legend = c("Rural", "Urban"), pch = 16)
abline(a = coefs[1], b = coefs[2], col = 1, lwd = 3)
abline(a = coefs[1] + coefs[3], b = coefs[2] + coefs[4], col = 2, lwd = 3)
text(x = 10.25, y = 9.75, col = 1,
paste0("Slope = ", coefs[2]))
text(x = 10.25, y = 8.5, col = 2,
paste0("Slope = ", coefs[2] + coefs[4]))
text(x = 10.25, y = 8.15, col = 2, paste0("but, p ≈ ", round(summary(lm1)$coefficients[4, 4], 2)))
text(x = 10.95, y = 6, col = 1, paste0("Rural energy use tends to be"))
text(x = 10.95, y = 5.65, col = 1, paste0("higher than urban, p-value ≈ ", round(summary(lm1)$coefficients[2, 4], 5), ","))
text(x = 10.95, y = 5.30, col = 1, "for households of similar incomes.")
##FROM CLASS 19
#Creating the linear model
mod1 <- regsubsets(logKWH ~ logIncBracket + DIVISION + UATYP10 + KOWNRENT + DIVISION*UATYP10,
data = cleanRECS, nvmax = 7)
mod1sum <- summary(mod1)
mod1sum$which
mod1sum$which[1, ]
lm1 <- lm(cleanRECS$logKWH ~ cleanRECS$logIncBracket*cleanRECS$UrbanRural)
summary(lm1)
coefs <- round(coef(lm1), 2)
#Plotting the model to show the lack of impact of household income, but impact of housing type.
plot(cleanRECS$logKWH ~ cleanRECS$logIncBracket,
col = factor(cleanRECS$UrbanRural),
pch = 16,
cex = .5,
main = "Energy Consumption vs. Household Income (Log-Log)",
xlab = "Log of Household Income Bracket ($)",
ylab = "Log of Energy Consumption (kWh)")
legend("topleft", col = 1:5, legend = c("Rural", "Urban"), pch = 16)
abline(a = coefs[1], b = coefs[2], col = 1, lwd = 3)
abline(a = coefs[1] + coefs[3], b = coefs[2] + coefs[4], col = 2, lwd = 3)
text(x = 10.25, y = 9.75, col = 1,
paste0("Slope = ", coefs[2]))
text(x = 10.25, y = 8.5, col = 2,
paste0("Slope = ", coefs[2] + coefs[4]))
text(x = 10.25, y = 8.15, col = 2, paste0("but, p ≈ ", round(summary(lm1)$coefficients[4, 4], 2)))
text(x = 10.95, y = 6, col = 1, paste0("Rural energy use tends to be"))
text(x = 10.95, y = 5.65, col = 1, paste0("higher than urban, p-value ≈ ", round(summary(lm1)$coefficients[2, 4], 5), ","))
text(x = 10.95, y = 5.30, col = 1, "for households of similar incomes.")
myResPlots2(lm(cleanRECS$IncBracket ~ logKWH))
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$KWH))
myResPlots2(lm(cleanRECS$logIncBracket ~ cleanRECS$KWH))
myResPlots2(lm(cleanRECS$logIncBracket ~ cleanRECS$logKWH))
boxcox(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
names(incomeTrans)
incomeTrans <- boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
names(incomeTrans)
#LIAM write up an explanation for this transformation
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$KWH))
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
myResPlots2(lm(cleanRECS$logIncBracket ~ cleanRECS$KWH))
myResPlots2(lm(cleanRECS$logIncBracket ~ cleanRECS$logKWH))
incomeTrans <- boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
library(MASS)
round(fractions(incomeTrans$x[which.max(incomeTrans$y)]), 2)
#LIAM write up an explanation for this transformation
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$KWH))
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
myResPlots2(lm(cleanRECS$logIncBracket ~ cleanRECS$KWH))
myResPlots2(lm(cleanRECS$logIncBracket ~ cleanRECS$logKWH))
incomeTrans <- boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
library(MASS)
round(fractions(incomeTrans$x[which.max(incomeTrans$y)]), 1)
#LIAM write up an explanation for this transformation
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$KWH))
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
myResPlots2(lm(cleanRECS$logIncBracket ~ cleanRECS$KWH))
myResPlots2(lm(cleanRECS$logIncBracket ~ cleanRECS$logKWH))
incomeTrans <- boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
round(incomeTrans$x[which.max(incomeTrans$y)], 2)
round(incomeTrans$x[which.max(incomeTrans$y)], 2)
incomeTrans <- boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
round(incomeTrans$x[which.max(incomeTrans$y)], 2)
cleanRECS$transIncome <- cleanRECS$IncBracket^round(incomeTrans$x[which.max(incomeTrans$y)], 1)
myResPlots2(lm(cleanRECS$transIncome ~ cleanRECS$logKWH))
round(incomeTrans$x[which.max(incomeTrans$y)], 2)
incomeTrans <- boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$KWH))
round(incomeTrans$x[which.max(incomeTrans$y)], 2)
incomeTrans <- boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$KWH))
round(incomeTrans$x[which.max(incomeTrans$y)], 2)
incomeTrans <- boxCox(lm(cleanRECS$IncBracket ~ cleanRECS$KWH))
round(incomeTrans$x[which.max(incomeTrans$y)], 2)
round(incomeTrans$x[which.max(incomeTrans$y)], 1)
cleanRECS$transIncome <- cleanRECS$IncBracket^0.4
myResPlots2(lm(cleanRECS$transIncome ~ cleanRECS$logKWH))
myResPlots2(lm(cleanRECS$transIncome ~ cleanRECS$KWH))
myResPlots(cleanRECS$IncBracket)
qqPlot(cleanRECS$IncBracket)
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
qqPlot(logIncBracket)
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
qqPlot(cleanRECS$logIncBracket)
qqPlot(cleanRECS$logIncBracket)
#We see in the below residual plots that neither income nor the residuals of income for predicting the log of energy use are normally distributed. We are not surprised regarding the distribution of income, because it is generally expected to be normally distributed only when transformed in a log scale, and in this case we only have single lines representing income brackets. We therefore go with the standard linear transformation generally used for income variables.
myResPlots2(lm(cleanRECS$IncBracket ~ cleanRECS$logKWH))
cleanRECS$logIncBracket <- log(cleanRECS$IncBracket)
##FROM CLASS 19
#Creating the linear model
mod1 <- regsubsets(logKWH ~ logIncBracket + DIVISION + UATYP10 + KOWNRENT + DIVISION*UATYP10,
data = cleanRECS, nvmax = 7)
mod1sum <- summary(mod1)
mod1sum$which
mod1sum$which[1, ]
##FROM CLASS 19
#Creating the linear model
mod1 <- regsubsets(logKWH ~ logIncBracket + DIVISION + UATYP10 + KOWNRENT + DIVISION*UATYP10,
data = cleanRECS, nvmax = 7)
mod1sum <- summary(mod1)
mod1sum$which[1, ]
#Check Variance Assumption
stdev2 <- tapply(KWH, CENACHP, sd)
round(max(stdev2)/min(stdev2),1)
round(max(stdev2)/min(stdev2),1) <= 2
